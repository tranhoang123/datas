"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bBot = __importStar(require(".."));
const mongoose_1 = __importDefault(require("mongoose"));
const models = {};
function getModel(collection) {
    if (!models[collection]) {
        delete mongoose_1.default.connection.models[collection];
        models[collection] = mongoose_1.default.model(collection, new mongoose_1.default.Schema({
            type: { type: String },
            sub: { type: String, lowercase: true },
            data: { type: mongoose_1.default.Schema.Types.Mixed }
        }, { collection }));
    }
    return models[collection];
}
exports.getModel = getModel;
class Mongo extends bBot.StorageAdapter {
    constructor(bot) {
        super(bot);
        this.name = 'mongo-storage-adapter';
        this.config = {
            useNewUrlParser: true,
            autoIndex: true,
            reconnectTries: Number.MAX_VALUE,
            reconnectInterval: 500,
            poolSize: 10,
            keepAlive: 120
        };
        this.bot.settings.extend({
            'db-url': {
                type: 'string',
                alias: 'mongodb-url',
                description: 'Storage adapter address for mongo database',
                default: `mongodb://127.0.0.1:27017/${bot.settings.name}-brain`
            },
            'db-collection': {
                type: 'string',
                alias: 'brain-collection',
                description: 'Collection in DB for the bot brain and state data',
                default: `brain`
            }
        });
        this.model = getModel(this.bot.settings.get('db-collection'));
        this.bot.logger.info(`[mongo] using Mongo as storage adapter.`);
        this.bot.logger.debug(`[mongo] storing to '${this.bot.settings.get('db-collection')}' collection at ${this.bot.settings.get('db-url')}`);
    }
    static getInstance(bot) {
        if (!Mongo.instance)
            Mongo.instance = new Mongo(bot);
        return Mongo.instance;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.logger.info(`[mongo] connecting to Mongo DB at ${this.bot.settings.get('db-url')}`);
            this.store = yield mongoose_1.default.connect(this.bot.settings.get('db-url'), this.config);
            this.bot.logger.debug(`[mongo] connected to Mongo DB`);
            return;
        });
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            yield mongoose_1.default.disconnect();
            return;
        });
    }
    saveMemory(data) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let sub in data) {
                const query = { sub, type: 'memory' };
                const doc = { data: data[sub] };
                const options = { upsert: true, lean: true };
                yield this.model.findOneAndUpdate(query, doc, options).exec();
            }
            return;
        });
    }
    loadMemory() {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.logger.debug(`[mongo] loading memory data from DB`);
            const query = { type: 'memory' };
            const fields = { _id: 0, 'data': 1, 'sub': 1 };
            const opts = { lean: true };
            const docs = yield this.model.find(query, fields, opts).exec();
            if (!docs)
                return undefined;
            const memory = {};
            for (let doc of docs) {
                if (doc.sub === 'users') {
                    if (!memory[doc.sub])
                        memory[doc.sub] = {};
                    for (let id in doc.data) {
                        memory[doc.sub][id] = new this.bot.User(doc.data[id]);
                    }
                }
                else {
                    memory[doc.sub] = doc.data;
                }
            }
            return memory;
        });
    }
    keep(sub, data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.bot.logger.debug(`[mongo] keep ${sub} value in DB`);
                const query = { sub, type: 'store' };
                const update = { $push: { data } };
                const options = { upsert: true };
                yield this.model.findOneAndUpdate(query, update, options).lean().exec();
                this.bot.logger.debug(`[mongo] kept ${sub}: ${JSON.stringify(update)}`);
            }
            catch (err) {
                this.bot.logger.error(`[mongo] keep error for ${sub}`, err);
            }
        });
    }
    find(sub, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.logger.debug(`[mongo] finding any ${sub} matching ${params}`);
            const query = { sub, data: { $elemMatch: params }, type: 'store' };
            const fields = { _id: 0, 'data': 1 };
            const doc = yield this.model.findOne(query, fields).lean().exec();
            if (!doc)
                return undefined;
            const matching = doc.data.filter((item) => {
                if (!Object.keys(params).length)
                    return true;
                let match = false;
                for (let key in params) {
                    const valueAtKey = key.split('.').reduce((pre, cur) => pre[cur], item);
                    match = (valueAtKey === params[key]);
                }
                return match;
            });
            this.bot.logger.debug(`[mongo] found ${matching.length} matching ${sub}s.`);
            return matching;
        });
    }
    findOne(sub, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.logger.debug(`[mongo] finding a ${sub} matching ${params}`);
            const query = { sub, data: { $elemMatch: params }, type: 'store' };
            const fields = { _id: 0, 'data.$': 1 };
            const doc = yield this.model.findOne(query, fields).lean().exec();
            if (!doc)
                return undefined;
            this.bot.logger.debug(`[mongo] found a ${sub}: ${JSON.stringify(doc.data[0])}`);
            return doc.data[0];
        });
    }
    lose(sub, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.bot.logger.debug(`[mongo] losing a ${sub} matching ${params}`);
            const query = { sub, type: 'store' };
            const update = { $pull: { data: params } };
            const options = { upsert: true };
            yield this.model.findOneAndUpdate(query, update, options).lean().exec();
        });
    }
}
exports.Mongo = Mongo;
exports.use = (bot) => Mongo.getInstance(bot);
