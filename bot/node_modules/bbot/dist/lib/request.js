"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const client = __importStar(require("request"));
const bot = __importStar(require(".."));
function timeoutPromise(ms, promise) {
    let timeout = new Promise((_, reject) => {
        let id = setTimeout(() => {
            clearTimeout(id);
            reject(new Error(`[request] Timed out in ${ms}ms.`));
        }, ms);
    });
    return Promise.race([promise, timeout]);
}
class Request {
    make(opts) {
        bot.logger.info(`[request] ${opts.method} ${opts.uri} ${(opts.body || opts.qs)
            ? 'with data (' + Object.keys(opts.body || opts.qs).join(', ') + ')'
            : 'without data'}`);
        const requestPromise = new Promise((resolve, reject) => {
            opts.callback = (err, res, body) => {
                const result = res && res.statusCode ? res.statusCode : 'unknown';
                if (err) {
                    bot.logger.error(`[request] ${opts.method} error ${err.code}`);
                    return reject(err);
                }
                if (Buffer.isBuffer(body)) {
                    return reject(new Error(`[request] ${opts.method} error, body is buffer, not JSON`));
                }
                try {
                    const data = (opts.json) ? body : JSON.parse(body);
                    const keys = Object.keys(data).join(', ');
                    bot.logger.info(`[request] ${opts.method} ${result} success (${keys})`);
                    resolve(data);
                }
                catch (err) {
                    bot.logger.error(`[request] ${opts.method} error parsing body: ${err.message}`);
                    reject(err);
                }
            };
            if (!opts.method || opts.method === 'GET')
                client.get(opts);
            else if (opts.method === 'POST')
                client.post(opts);
            else if (opts.method === 'PUT')
                client.put(opts);
            else if (opts.method === 'PATCH')
                client.patch(opts);
            else if (opts.method === 'DELETE')
                client.del(opts);
            else if (opts.method === 'HEAD')
                client.head(opts);
        });
        return timeoutPromise(bot.settings.get('request-timeout'), requestPromise);
    }
    get(url, data, options) {
        const opts = {
            method: 'GET',
            uri: url,
            qs: data
        };
        if (options)
            Object.assign(opts, options);
        return this.make(opts);
    }
    post(url, data = {}, options) {
        const opts = {
            method: 'POST',
            uri: url,
            body: data,
            json: true
        };
        if (options)
            Object.assign(opts, options);
        return this.make(opts);
    }
}
exports.Request = Request;
exports.request = new Request();
