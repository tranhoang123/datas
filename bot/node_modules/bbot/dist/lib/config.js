"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("dotenv/config");
const yargs = __importStar(require("yargs"));
const json_1 = require("./json");
const argsInfo = `
All option can be provided as environment variables, with the prefix \`BOT_\`.
Config can also be declared in \`package.json\` with the key: "botConfig".
For more information, see http://bbot.chat/docs/config'
`;
const argsError = (msg, err) => {
    console.error(msg, err);
    console.info('Start with --help for config argument info.');
    if (err)
        throw err;
    process.exit(1);
};
function hyphenate(str) {
    return str.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`);
}
exports.hyphenate = hyphenate;
function camelCase(str) {
    return str.replace(/-([a-z])/gi, (g) => g[1].toUpperCase());
}
exports.camelCase = camelCase;
const initOptions = {
    'name': {
        type: 'string',
        describe: 'Name of the bot in chat. Prepending any command with the name will trigger `direct` branches.',
        alias: 'n',
        default: 'bot'
    },
    'alias': {
        type: 'string',
        describe: 'Alternate name for the bot.'
    },
    'log-level': {
        type: 'string',
        describe: 'The starting minimum level for logging events (silent|debug|info|warn|error).',
        default: 'info'
    },
    'auto-save': {
        type: 'boolean',
        describe: 'Save data in the brain every 5 seconds (defaults true).',
        default: true
    },
    'use-server': {
        type: 'boolean',
        describe: 'Enable/disable the internal Koa server for incoming requests and http/s messages.',
        default: true
    },
    'server-host': {
        type: 'string',
        describe: 'The host the bot is running on.',
        default: 'localhost'
    },
    'server-port': {
        type: 'string',
        describe: 'The port the server should listen on.',
        default: '3000'
    },
    'server-secure': {
        type: 'boolean',
        describe: 'Server should listen on HTTPS only.',
        default: false
    },
    'message-adapter': {
        type: 'string',
        describe: 'Local path or NPM package name to require as message platform adapter',
        alias: 'm',
        default: './adapters/shell'
    },
    'nlu-adapter': {
        type: 'string',
        describe: 'Local path or NPM package name to require as message platform adapter',
        alias: 'l',
        default: null
    },
    'storage-adapter': {
        type: 'string',
        describe: 'Local path or NPM package name to require as storage engine adapter',
        alias: 's',
        default: null
    },
    'nlu-min-length': {
        type: 'number',
        describe: 'Minimum string length for NLU parsing to apply on message',
        default: 10
    },
    'request-timeout': {
        type: 'number',
        describe: 'Maximum milliseconds to wait for a http/s request to resolve',
        default: 1500
    }
};
class Settings {
    constructor() {
        this.options = Object.assign({}, initOptions);
        this.config = this.loadConfig(true);
        this.updates = {};
    }
    loadConfig(reset = false) {
        const options = {};
        for (let key in this.options) {
            const opt = Object.assign({}, this.options[key]);
            if (this.config) {
                if (typeof opt.global === 'undefined')
                    opt.global = false;
            }
            options[key] = opt;
        }
        const config = yargs
            .options(options)
            .usage('\nUsage: $0 [args]')
            .env('BOT')
            .pkgConf('bot')
            .config()
            .alias('config', 'c')
            .example('config', 'bin/bbot -c bot-config.json')
            .version(json_1.packageJSON.version)
            .alias('version', 'v')
            .help()
            .alias('h', 'help')
            .epilogue(argsInfo)
            .fail(argsError)
            .argv;
        if (reset)
            this.updates = {};
        else
            for (let key in this.updates)
                config[key] = this.updates[key];
        for (let key in config) {
            if (Object.keys(this.options).indexOf(hyphenate(key)) < 0) {
                delete config[key];
            }
        }
        return config;
    }
    reloadConfig() {
        this.config = this.loadConfig(false);
    }
    resetConfig() {
        this.options = Object.assign({}, initOptions);
        this.config = this.loadConfig(true);
    }
    safeName(name) { return name.replace(/[^a-z0-9_-]/ig, ''); }
    get name() { return this.get('name'); }
    set name(name) { this.set('name', this.safeName(name)); }
    get alias() { return this.get('alias'); }
    set alias(name) { this.set('alias', this.safeName(name)); }
    get(key) {
        return (this.config) ? this.config[key] : undefined;
    }
    set(key, value) {
        this.config[key] = value;
        this.updates[key] = value;
        if (key === hyphenate(key)) {
            this.config[camelCase(key)] = value;
            this.updates[camelCase(key)] = value;
        }
        else if (key === camelCase(key)) {
            this.config[hyphenate(key)] = value;
            this.updates[hyphenate(key)] = value;
        }
    }
    unset(key) {
        delete this.config[key];
        delete this.config[camelCase(key)];
        delete this.config[hyphenate(key)];
        delete this.updates[key];
        delete this.updates[camelCase(key)];
        delete this.updates[hyphenate(key)];
        this.reloadConfig();
    }
    extend(options) {
        this.options = Object.assign({}, this.options, options);
        this.reloadConfig();
    }
}
exports.Settings = Settings;
exports.settings = new Settings();
exports.getConfig = () => exports.settings.loadConfig();
if (process.platform !== 'win32')
    process.on('SIGTERM', () => process.exit(0));
