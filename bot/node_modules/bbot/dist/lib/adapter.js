"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const bot = __importStar(require(".."));
function loadAdapter(adapterPath) {
    if (!adapterPath)
        return;
    let isPath = /^(\/|\.|\\)/.test(adapterPath);
    if (!isPath) {
        bot.logger.debug(`[adapter] loading adapter by name: ${adapterPath}`);
        try {
            if (require.main) {
                return require(require.resolve(adapterPath, {
                    paths: require.main.paths
                })).use(bot);
            }
            else
                return require(adapterPath);
        }
        catch (err) {
            if (/cannot find/i.test(err.message)) {
                bot.logger.debug(`[adapter] failed to load module, will try from path`);
            }
            else {
                bot.logger.error('[adapter] failed loading due to internal error');
                throw err;
            }
        }
    }
    if (!isPath)
        adapterPath = `./adapters/${adapterPath}`;
    bot.logger.debug(`[adapter] loading adapter by path: ${adapterPath}`);
    let sourcePath = 'src';
    let distPath = 'dist';
    let modulePath = 'node_modules/bbot/dist';
    let currentPath = process.cwd();
    let currentModule = path_1.default.resolve(currentPath, modulePath);
    let resolver = { paths: [sourcePath, distPath, currentPath, currentModule] };
    if (require.main)
        resolver.paths = resolver.paths.concat(...require.main.paths);
    try {
        adapterPath = require.resolve(adapterPath, resolver);
        return require(adapterPath).use(bot);
    }
    catch (err) {
        bot.logger.error(`[adapter] loading failed: ${err.message}`);
        throw err;
    }
}
exports.loadAdapter = loadAdapter;
const adapterTypes = ['message', 'nlu', 'storage'];
class Adapters {
    load() {
        for (let type of adapterTypes) {
            const adapterPath = bot.settings.get(`${type}-adapter`);
            if (adapterPath && adapterPath !== '' && !this[type]) {
                try {
                    this[type] = loadAdapter(adapterPath);
                }
                catch (err) {
                    bot.logger.error(err.message);
                    throw new Error(`[adapter] failed to load all adapters`);
                }
            }
        }
    }
    start() {
        return Promise.all(Object.keys(this).map((type) => {
            let adapter = this[type];
            if (adapter) {
                bot.logger.debug(`[adapter] starting ${type} adapter: ${adapter.name}`);
                return Promise.resolve(adapter.start()).catch((err) => {
                    bot.logger.error(`[adapter] startup failed: ${err.message}`);
                    throw err;
                });
            }
            else {
                bot.logger.debug(`[adapter] no ${type} type adapter defined`);
            }
            return undefined;
        }));
    }
    shutdown() {
        return Promise.all(Object.keys(this).map((type) => {
            let adapter = this[type];
            if (adapter) {
                bot.logger.debug(`[adapter] shutdown ${type} adapter: ${adapter.name}`);
                return Promise.resolve(adapter.shutdown());
            }
            return undefined;
        }));
    }
    unload() {
        for (let type of adapterTypes)
            delete this[type];
    }
}
exports.Adapters = Adapters;
exports.adapters = new Adapters();
