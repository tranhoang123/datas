"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NaturalLanguageResult extends Array {
    indexIncludes(index, criteria) {
        if (!Object.keys(criteria).some((key) => {
            return (['id', 'name', 'score'].includes(key));
        }))
            throw new Error('[nlu] Result matching requires ID, name or score');
        if (this[index] === void 0)
            return undefined;
        const { id, name, score } = criteria;
        const result = this[index];
        let found = true;
        if (id || name) {
            if (id && result.id !== id)
                found = false;
            if (name && result.name !== name)
                found = false;
        }
        else if (result.score !== score)
            found = false;
        if (found)
            return result;
        return undefined;
    }
    sortByScore() {
        this.sort((a, b) => {
            if (typeof a.score !== 'undefined' && typeof b.score !== 'undefined') {
                return b.score - a.score;
            }
            if (typeof a.score !== 'undefined' || typeof b.score !== 'undefined') {
                return (a.score) ? 1 : -1;
            }
            return 0;
        });
    }
    match(criteria) {
        let { score, operator } = criteria;
        if (!operator)
            operator = (typeof score === 'undefined') ? 'in' : 'gte';
        let matching;
        let matched;
        this.sortByScore();
        if (['eq', 'gte', 'gt', 'lt', 'lte'].includes(operator) &&
            typeof score === 'undefined')
            throw new Error('[nlu] Result cannot match score without score criteria');
        if (['eq', 'gte', 'gt', 'lt', 'lte'].includes(operator) &&
            Object.keys(criteria).some((key) => !['score', 'operator'].includes(key)))
            matched = this.filter((_, index) => this.indexIncludes(index, criteria));
        else
            matched = Array.from(this);
        if (!matched.length)
            return undefined;
        switch (operator) {
            case 'in':
                matched = this.filter((_, index) => this.indexIncludes(index, criteria));
                return matched.length ? matched : undefined;
            case 'is':
                if (this.length === 1)
                    matching = this.indexIncludes(0, criteria);
                return matching ? [matching] : undefined;
            case 'max':
                matching = this.indexIncludes(0, criteria);
                return matching ? [matching] : undefined;
            case 'min':
                matching = this.indexIncludes(this.length - 1, criteria);
                return matching ? [matching] : undefined;
            case 'eq':
                matched = matched.filter((item) => (typeof item.score !== 'undefined' && item.score === 0));
                return (matched.length) ? matched : undefined;
            case 'gte':
                matched = matched.filter((item) => (typeof item.score !== 'undefined' && item.score >= score));
                return (matched.length) ? matched : undefined;
            case 'gt':
                matched = matched.filter((item) => (typeof item.score !== 'undefined' && item.score > score));
                return (matched.length) ? matched : undefined;
            case 'lt':
                matched = matched.filter((item) => (typeof item.score !== 'undefined' && item.score < score));
                return (matched.length) ? matched : undefined;
            case 'lte':
                matched = matched.filter((item) => (typeof item.score !== 'undefined' && item.score <= score));
                return (matched.length) ? matched : undefined;
        }
        return;
    }
    add(...results) {
        for (let result of results)
            this.push(result);
        return this;
    }
}
exports.NaturalLanguageResult = NaturalLanguageResult;
var NLUKey;
(function (NLUKey) {
    NLUKey[NLUKey["intent"] = 0] = "intent";
    NLUKey[NLUKey["entities"] = 1] = "entities";
    NLUKey[NLUKey["sentiment"] = 2] = "sentiment";
    NLUKey[NLUKey["tone"] = 3] = "tone";
    NLUKey[NLUKey["phrases"] = 4] = "phrases";
    NLUKey[NLUKey["act"] = 5] = "act";
    NLUKey[NLUKey["language"] = 6] = "language";
})(NLUKey = exports.NLUKey || (exports.NLUKey = {}));
class NLU {
    constructor() {
        this.results = {};
    }
    addResult(key, ...results) {
        if (this.results[key] instanceof NaturalLanguageResult) {
            this.results[key].add(...results);
        }
        else {
            this.results[key] = new NaturalLanguageResult().add(...results);
        }
        return this;
    }
    addResults(results) {
        for (let key in results) {
            let nluKey = key;
            if (results[nluKey])
                this.addResult(nluKey, ...results[nluKey]);
        }
        return this;
    }
    matchCriteria(key, criteria) {
        if (this.results[key])
            return this.results[key].match(criteria);
        return undefined;
    }
    matchAllCriteria(criteria) {
        const matched = {};
        for (let key in criteria) {
            let nluKey = key;
            const match = this.matchCriteria(nluKey, criteria[nluKey]);
            if (match)
                matched[nluKey] = match;
        }
        if (Object.keys(matched).length)
            return matched;
        return undefined;
    }
    printResults() {
        const outputs = [];
        for (let key of Object.keys(this.results)) {
            const items = this.results[key];
            if (items && items.length) {
                let details = items.map((item) => {
                    const score = (typeof item.score !== 'undefined')
                        ? ` ${item.score.toFixed(2)}`
                        : '';
                    return `${item.name || item.id}${score}`;
                }).join(', ');
                outputs.push(`${key} (${details})`);
            }
        }
        return outputs.join(', ');
    }
}
exports.NLU = NLU;
