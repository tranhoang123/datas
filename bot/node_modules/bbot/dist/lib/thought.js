"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bot = __importStar(require(".."));
class Thought {
    constructor(options) {
        this.validate = () => Promise.resolve(true);
        this.action = (_) => Promise.resolve();
        this.name = options.name;
        this.b = options.b;
        if (options.validate)
            this.validate = options.validate;
        if (options.action)
            this.action = options.action;
        if (options.branches)
            this.branches = options.branches;
        if (options.middleware)
            this.middleware = options.middleware;
        else if (bot.middlewares[this.name])
            this.middleware = bot.middlewares[this.name];
        else
            throw new Error('[thought] invalid middleware provided');
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.b.exit)
                return Promise.resolve();
            return new Promise((resolve, reject) => {
                const { b, name, validate, middleware, branches } = this;
                if (typeof branches !== 'undefined') {
                    if (Object.keys(branches).length === 0) {
                        bot.logger.debug(`[thought] skip ${name}, no branches to process`);
                        return reject();
                    }
                    if (b.done) {
                        bot.logger.debug(`[thought] skip ${name}, branch processing is done`);
                        return reject();
                    }
                }
                Promise.resolve(validate())
                    .then((valid) => __awaiter(this, void 0, void 0, function* () {
                    if (!valid)
                        return reject();
                    const branchCount = Object.keys(this.branches || {}).length;
                    const branchDetail = (branchCount)
                        ? ` against ${branchCount} branch${branchCount > 1 ? 'es' : ''}`
                        : ``;
                    if (b.message) {
                        bot.logger.debug(`[thought] ${b.scope} ${name} processing incoming message ID ${b.message.id}${branchDetail}`);
                    }
                    else if (b.envelopes) {
                        bot.logger.debug(`[thought] ${b.scope} ${name} processing outgoing envelopes${branchDetail}`);
                    }
                    if (typeof branches === 'undefined')
                        return middleware.execute(b, resolve).then(reject);
                    for (let id in branches) {
                        if (b.done)
                            break;
                        yield branches[id].process(b, middleware);
                    }
                    return (b.matched) ? resolve() : reject();
                }))
                    .catch((err) => {
                    bot.logger.debug(`[thought] ${name} validation error ${err.message}`);
                    reject(err);
                });
            })
                .then(() => {
                if (!this.b.processed[this.name])
                    this.b.processed[this.name] = Date.now();
                return this.action(true);
            })
                .catch((err) => {
                if (err instanceof Error) {
                    bot.logger.error(`[thought] ${this.name} error, ${err.message}`);
                    throw err;
                }
                return this.action(false);
            });
        });
    }
}
exports.Thought = Thought;
class Thoughts {
    constructor(state, path) {
        this.sequence = {
            serve: ['hear', 'serve', 'act', 'remember'],
            receive: ['hear', 'listen', 'understand', 'act', 'remember'],
            respond: ['respond'],
            dispatch: ['respond', 'remember']
        };
        this.b = state;
        this.path = (path) ? new bot.Path(path) : new bot.Path(bot.global);
        const { b } = this;
        this.processes = {
            hear: new bot.Thought({ name: 'hear', b }),
            listen: new bot.Thought({ name: 'listen', b, branches: this.path.listen }),
            understand: new bot.Thought({ name: 'understand', b, branches: this.path.understand }),
            serve: new bot.Thought({ name: 'serve', b, branches: this.path.serve }),
            act: new bot.Thought({ name: 'act', b, branches: this.path.act }),
            respond: new bot.Thought({ name: 'respond', b }),
            remember: new bot.Thought({ name: 'remember', b })
        };
        this.processes.hear.action = (success) => __awaiter(this, void 0, void 0, function* () {
            if (!success)
                b.finish();
        });
        this.processes.listen.action = (success) => __awaiter(this, void 0, void 0, function* () {
            if (success)
                this.path.forced('understand');
        });
        this.processes.understand.validate = () => __awaiter(this, void 0, void 0, function* () {
            if (!bot.adapters.nlu) {
                bot.logger.debug(`[thought] skip understand, no nlu adapter`);
            }
            else if (!(b.message instanceof bot.TextMessage)) {
                bot.logger.debug(`[thought] skip understand, not a text message`);
            }
            else if (b.message.toString().trim() === '') {
                bot.logger.debug(`[thought] skip understand, message text is empty`);
            }
            else if (bot.settings.get('nlu-min-length') &&
                b.message.toString().trim().length < bot.settings.get('nlu-min-length')) {
                bot.logger.debug(`[thought] skip understand, message text too short`);
            }
            else {
                const nluResultsRaw = yield bot.adapters.nlu.process(b.message);
                if (!nluResultsRaw || Object.keys(nluResultsRaw).length === 0) {
                    bot.logger.error(`[thought] nlu processing returned empty`);
                }
                else {
                    b.message.nlu = new bot.NLU().addResults(nluResultsRaw);
                    bot.logger.info(`[thought] nlu processed ${b.message.nlu.printResults()}`);
                    return true;
                }
            }
            return false;
        });
        this.processes.act.validate = () => __awaiter(this, void 0, void 0, function* () {
            if (b.matched)
                return false;
            if (b.message)
                b.message = new bot.CatchAllMessage(b.message);
            return true;
        });
        this.processes.respond.validate = () => __awaiter(this, void 0, void 0, function* () {
            if (!bot.adapters.message) {
                throw new Error('[thought] message adapter not found');
            }
            const envelope = b.pendingEnvelope();
            if (!envelope)
                return false;
            const branch = b.getBranch();
            if (branch)
                envelope.branchId = branch.id;
            return true;
        });
        this.processes.respond.action = (success) => __awaiter(this, void 0, void 0, function* () {
            if (success) {
                const envelope = b.respondEnvelope();
                yield bot.adapters.message.dispatch(envelope);
                envelope.responded = Date.now();
            }
        });
        this.processes.remember.validate = () => __awaiter(this, void 0, void 0, function* () {
            if (b.matched)
                bot.userById(b.message.user.id, b.message.user);
            if (!bot.adapters.storage) {
                bot.logger.debug(`[thought] skip remember, no storage adapter`);
            }
            else if (!b.matched && !b.dispatchedEnvelope()) {
                bot.logger.debug(`[thought] skip remember on outgoing`);
            }
            else {
                return true;
            }
            return false;
        });
        this.processes.remember.action = (success) => __awaiter(this, void 0, void 0, function* () {
            if (success)
                yield bot.store.keep('states', b);
        });
    }
    start(sequence) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sequence[sequence])
                throw new Error('[thought] invalid sequence');
            if (!this.b.sequence)
                this.b.sequence = sequence;
            if (!this.b.scope)
                this.b.scope = this.path.scope;
            for (let process of this.sequence[sequence]) {
                yield this.processes[process].process();
            }
            return this.b;
        });
    }
}
exports.Thoughts = Thoughts;
function receive(message, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const thought = new Thoughts(new bot.State({ message }), path);
        bot.logger.info(`[thought] receive message ID ${message.id}`);
        return thought.start('receive');
    });
}
exports.receive = receive;
function respond(b) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!b.branch) {
            bot.logger.info(`[thought] respond without matched branch`);
        }
        else {
            bot.logger.info(`[thought] respond to matched branch ${b.branch.id}`);
        }
        return new Thoughts(b).start('respond');
    });
}
exports.respond = respond;
function dispatch(envelope) {
    return __awaiter(this, void 0, void 0, function* () {
        bot.logger.info(`[thought] dispatch envelope ${envelope.id}`);
        return new Thoughts(new bot.State({ envelopes: [envelope] })).start('dispatch');
    });
}
exports.dispatch = dispatch;
function serve(message, context, path) {
    return __awaiter(this, void 0, void 0, function* () {
        bot.logger.info(`[thought] serving ${message.id} for ${message.user.id}`);
        return new Thoughts(new bot.State({ message, context }), path).start('serve');
    });
}
exports.serve = serve;
