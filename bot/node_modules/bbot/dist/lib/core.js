"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const bot = __importStar(require(".."));
exports.eventDelay = util_1.promisify(setImmediate);
const status = {
    waiting: 1, loading: 0, loaded: 0, starting: 0, started: 0, shutdown: 0
};
function setStatus(set) {
    for (let key of Object.keys(status))
        status[key] = (set === key) ? 1 : 0;
    if (set === 'loading') {
        bot.logger.info(`[core] ${bot.settings.name} loading  . . . . . ~(0_0)~`);
    }
    else if (set === 'starting') {
        bot.logger.info(`[core] ${bot.settings.name} starting . . . . . ┌(O_O)┘ bzzzt whirr`);
    }
    else if (set === 'started') {
        bot.logger.info(`[core] ${bot.settings.name} started  . . . . . ~(O_O)~ bleep bloop`);
    }
}
function getStatus() {
    for (let key of Object.keys(status))
        if (status[key] === 1)
            return key;
    return 'broken';
}
exports.getStatus = getStatus;
function load() {
    return __awaiter(this, void 0, void 0, function* () {
        bot.logger.level = bot.settings.get('log-level');
        if (getStatus() !== 'waiting')
            yield reset();
        setStatus('loading');
        try {
            bot.middlewares.load();
            bot.server.load();
            bot.adapters.load();
            yield exports.eventDelay();
            setStatus('loaded');
            bot.events.emit('loaded');
        }
        catch (err) {
            bot.logger.error('[core] failed to load');
            yield bot.shutdown(1).catch();
        }
    });
}
exports.load = load;
function start() {
    return __awaiter(this, void 0, void 0, function* () {
        if (getStatus() !== 'loaded')
            yield load();
        setStatus('starting');
        try {
            yield bot.server.start();
            yield bot.adapters.start();
            yield bot.memory.start();
        }
        catch (err) {
            bot.logger.error('[core] failed to start');
            yield bot.shutdown(1).catch();
        }
        yield exports.eventDelay();
        setStatus('started');
        bot.events.emit('started');
    });
}
exports.start = start;
function shutdown(exit = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const status = getStatus();
        if (status === 'shutdown')
            return;
        if (status === 'loading') {
            yield new Promise((resolve) => bot.events.on('loaded', () => resolve()));
        }
        else if (status === 'starting') {
            yield new Promise((resolve) => bot.events.on('started', () => resolve()));
        }
        yield bot.memory.shutdown();
        yield bot.adapters.shutdown();
        yield bot.server.shutdown();
        yield exports.eventDelay();
        setStatus('shutdown');
        bot.events.emit('shutdown');
        if (exit)
            process.exit(exit);
    });
}
exports.shutdown = shutdown;
function pause() {
    return __awaiter(this, void 0, void 0, function* () {
        yield shutdown();
        yield exports.eventDelay();
        setStatus('loaded');
        bot.events.emit('paused');
    });
}
exports.pause = pause;
function reset() {
    return __awaiter(this, void 0, void 0, function* () {
        const status = getStatus();
        if (status !== 'shutdown')
            yield shutdown();
        try {
            bot.adapters.unload();
            bot.middlewares.unload();
            bot.global.reset();
            bot.settings.resetConfig();
        }
        catch (err) {
            bot.logger.error('[core] failed to reset');
            yield bot.shutdown(1).catch();
        }
        yield exports.eventDelay();
        setStatus('waiting');
        bot.events.emit('waiting');
    });
}
exports.reset = reset;
