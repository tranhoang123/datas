"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bot = __importStar(require(".."));
class Middleware {
    constructor(type = 'default') {
        this.type = type;
        this.stack = [];
    }
    register(piece) {
        this.stack.push(piece);
    }
    execute(state, complete) {
        const b = (state instanceof bot.State) ? state : new bot.State(state);
        let isPending = true;
        return new Promise((resolve, reject) => {
            if (this.stack.length) {
                bot.logger.debug(`[middleware] executing ${this.type} middleware (size: ${this.stack.length})`);
            }
            const executePiece = (done, piece, cb) => __awaiter(this, void 0, void 0, function* () {
                const next = (newDone) => cb(newDone || done);
                try {
                    yield Promise.resolve(piece(b, next, done));
                }
                catch (err) {
                    err.state = b;
                    err.middleware = this.type;
                    bot.logger.error(err);
                    throw err;
                }
            });
            const reduceStack = () => __awaiter(this, void 0, void 0, function* () {
                let done = () => resolve(b);
                try {
                    for (let piece of this.stack) {
                        yield executePiece(done, piece, (newDone) => {
                            done = newDone;
                        });
                    }
                    if (isPending) {
                        yield Promise.resolve(complete(b));
                        yield Promise.resolve(done());
                    }
                }
                catch (err) {
                    reject(err);
                }
            });
            process.nextTick(() => reduceStack());
        }).then(() => {
            isPending = false;
            return b;
        });
    }
}
exports.Middleware = Middleware;
const middlewareTypes = [
    'hear', 'listen', 'understand', 'serve', 'act', 'respond', 'remember'
];
class Middlewares {
    constructor() {
    }
    load() {
        for (let type of middlewareTypes) {
            if (!this[type])
                this[type] = new Middleware(type);
        }
    }
    unload() {
        for (let type of middlewareTypes)
            delete this[type];
    }
}
exports.Middlewares = Middlewares;
exports.middlewares = new Middlewares();
exports.middleware = {};
for (let type of middlewareTypes) {
    exports.middleware[type] = (middlewarePiece) => {
        if (!exports.middlewares[type])
            exports.middlewares[type] = new Middleware(type);
        exports.middlewares[type].register(middlewarePiece);
    };
}
