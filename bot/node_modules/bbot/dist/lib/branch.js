"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bot = __importStar(require(".."));
class Branch {
    constructor(action, options = {}) {
        this.force = false;
        this.callback = (typeof action === 'string')
            ? (state) => bot.doBit(action, state)
            : action;
        this.id = (options.id) ? options.id : bot.counter('branch');
        for (let key in options)
            this[key] = options[key];
    }
    process(b, middleware, done = () => null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!b.matched || this.force) {
                this.match = yield Promise.resolve(this.matcher(b.message));
                this.matched = (this.match) ? true : false;
                if (this.matched) {
                    b.setBranch(this);
                    yield middleware.execute(b, (b) => {
                        bot.logger.debug(`[branch] executing ${this.constructor.name} callback, ID ${this.id}`);
                        return Promise.resolve(this.callback(b));
                    }).then(() => {
                        bot.logger.debug(`[branch] ${this.id} process done (${(this.matched) ? 'matched' : 'no match'})`);
                        return Promise.resolve(done(true));
                    }).catch((err) => {
                        bot.logger.error(`[branch] ${this.id} middleware error, ${err.message}`);
                        return Promise.resolve(done(false));
                    });
                }
                else {
                    yield Promise.resolve(done(false));
                }
            }
            return b;
        });
    }
}
exports.Branch = Branch;
class CatchAllBranch extends Branch {
    constructor(action, options) {
        super(action, options);
    }
    matcher(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message instanceof bot.CatchAllMessage) {
                bot.logger.debug(`[branch] message "${message}" matched catch all ID ${this.id}`);
                return message;
            }
            return undefined;
        });
    }
}
exports.CatchAllBranch = CatchAllBranch;
class CustomBranch extends Branch {
    constructor(customMatcher, action, options) {
        super(action, options);
        this.customMatcher = customMatcher;
    }
    matcher(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const match = yield Promise.resolve(this.customMatcher(message));
            if (match) {
                bot.logger.debug(`[branch] message "${message}" matched custom branch ID ${this.id}`);
            }
            return match;
        });
    }
}
exports.CustomBranch = CustomBranch;
class TextBranch extends Branch {
    constructor(conditions, callback, options) {
        super(callback, options);
        this.conditions = (conditions instanceof bot.Conditions)
            ? conditions
            : new bot.Conditions(conditions);
    }
    matcher(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this.conditions.exec(message.toString());
            const match = this.conditions.match;
            if (match) {
                bot.logger.debug(`[branch] message "${message}" matched branch ${this.id} conditions`);
            }
            return match;
        });
    }
}
exports.TextBranch = TextBranch;
class TextDirectBranch extends TextBranch {
    matcher(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (directPattern().exec(message.toString())) {
                const indirectMessage = message.clone();
                indirectMessage.text = message.text.replace(directPattern(), '');
                return _super("matcher").call(this, indirectMessage);
            }
            else {
                return false;
            }
        });
    }
}
exports.TextDirectBranch = TextDirectBranch;
class NaturalLanguageBranch extends Branch {
    constructor(criteria, callback, options) {
        super(callback, options);
        this.criteria = criteria;
    }
    matcher(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!message.nlu) {
                bot.logger.error(`[branch] NaturalLanguageBranch attempted matching without NLU, ID ${this.id}`);
                return undefined;
            }
            const match = message.nlu.matchAllCriteria(this.criteria);
            if (match) {
                bot.logger.debug(`[branch] NLU matched language branch ID ${this.id}`);
                return match;
            }
            return undefined;
        });
    }
}
exports.NaturalLanguageBranch = NaturalLanguageBranch;
class NaturalLanguageDirectBranch extends NaturalLanguageBranch {
    matcher(message) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (directPattern().exec(message.toString())) {
                return _super("matcher").call(this, message);
            }
            else {
                return undefined;
            }
        });
    }
}
exports.NaturalLanguageDirectBranch = NaturalLanguageDirectBranch;
class ServerBranch extends Branch {
    constructor(criteria, callback, options) {
        super(callback, options);
        this.criteria = criteria;
    }
    matcher(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const match = {};
            if (Object.keys(this.criteria).length === 0 &&
                (typeof message.data === 'undefined' ||
                    Object.keys(message.data).length === 0)) {
                return match;
            }
            else {
                if (!message.data) {
                    bot.logger.error(`[branch] server branch attempted matching without data, ID ${this.id}`);
                    return undefined;
                }
            }
            for (let path in this.criteria) {
                const valueAtPath = path.split('.').reduce((pre, cur) => {
                    return (typeof pre !== 'undefined') ? pre[cur] : undefined;
                }, message.data);
                if (this.criteria[path] instanceof RegExp &&
                    this.criteria[path].exec(valueAtPath))
                    match[path] = this.criteria[path].exec(valueAtPath);
                else if (this.criteria[path] === valueAtPath ||
                    this.criteria[path].toString() === valueAtPath)
                    match[path] = valueAtPath;
            }
            if (Object.keys(match).length) {
                bot.logger.debug(`[branch] Data matched server branch ID ${this.id}`);
                return match;
            }
            return undefined;
        });
    }
}
exports.ServerBranch = ServerBranch;
function directPattern() {
    const botName = bot.settings.name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    if (!bot.settings.alias) {
        return new RegExp(`^\\s*[@]?${botName}[:,]?\\s*`, 'i');
    }
    const botAlias = bot.settings.alias.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    if (botName.length > botAlias.length) {
        return new RegExp(`^\\s*[@]?(?:${botName}[:,]?|${botAlias}[:,]?)\\s*`, 'i');
    }
    return new RegExp(`^\\s*[@]?(?:${botAlias}[:,]?|${botName}[:,]?)\\s*`, 'i');
}
exports.directPattern = directPattern;
function directPatternCombined(regex) {
    const regexWithoutModifiers = regex.toString().split('/');
    regexWithoutModifiers.shift();
    const modifiers = regexWithoutModifiers.pop();
    const pattern = regexWithoutModifiers.join('/');
    const botName = bot.settings.name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    if (!bot.settings.alias) {
        return new RegExp(`^\\s*[@]?${botName}[:,]?\\s*(?:${pattern})`, modifiers);
    }
    const botAlias = bot.settings.alias.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    if (botName.length > botAlias.length) {
        return new RegExp(`^\\s*[@]?(?:${botName}[:,]?|${botAlias}[:,]?)\\s*(?:${pattern})`, modifiers);
    }
    return new RegExp(`^\\s*[@]?(?:${botAlias}[:,]?|${botName}[:,]?)\\s*(?:${pattern})`, modifiers);
}
exports.directPatternCombined = directPatternCombined;
