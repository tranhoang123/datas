"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const to_regex_range_1 = __importDefault(require("to-regex-range"));
var ConditionKey;
(function (ConditionKey) {
    ConditionKey[ConditionKey["is"] = 0] = "is";
    ConditionKey[ConditionKey["starts"] = 1] = "starts";
    ConditionKey[ConditionKey["ends"] = 2] = "ends";
    ConditionKey[ConditionKey["contains"] = 3] = "contains";
    ConditionKey[ConditionKey["excludes"] = 4] = "excludes";
    ConditionKey[ConditionKey["after"] = 5] = "after";
    ConditionKey[ConditionKey["before"] = 6] = "before";
    ConditionKey[ConditionKey["range"] = 7] = "range";
})(ConditionKey = exports.ConditionKey || (exports.ConditionKey = {}));
function isCondition(c) {
    if (!Object.keys(c).length)
        return false;
    for (let key in c) {
        const validKeys = Object.keys(ConditionKey).filter((k) => {
            return isNaN(Number(k)) === true;
        });
        if (validKeys.indexOf(key) < 0)
            return false;
    }
    return true;
}
function isConditionCollection(c) {
    if (!Object.keys(c).length)
        return false;
    for (let key in c) {
        if (!isCondition(c[key]))
            return false;
    }
    return true;
}
const _defaults = {
    matchWord: true,
    ignoreCase: true,
    ignorePunctuation: false
};
class Expression {
    fromString(str) {
        const match = str.match(new RegExp('^/(.+)/(.*)$'));
        let re = null;
        if (match)
            re = new RegExp(match[1], match[2]);
        if (!match || !(re instanceof RegExp)) {
            throw new Error(`[expression] ${str} can not convert to expression`);
        }
        return re;
    }
    escape(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }
    fromCondition(condition, options = _defaults) {
        const config = Object.assign({}, _defaults, options);
        const b = (config.matchWord) ? '\\b' : '';
        const i = (config.ignoreCase) ? 'i' : '';
        const p = (config.ignorePunctuation)
            ? `\\,\\-\\:\\[\\]\\/\\(\\)\\+\\?\\.\\'\\$`
            : '\\,\\-\\:';
        const patterns = [];
        for (let cKey of Object.keys(condition)) {
            const type = cKey;
            let value = condition[type];
            if (typeof value === 'string')
                value = [value];
            value = value.map((v) => (type === 'range') ? v : this.escape(v));
            if (config.ignorePunctuation) {
                value = value.map((v) => v.replace(/([^\\\w\s])/g, '$1+'));
            }
            value = value.join('|');
            switch (type) {
                case 'is':
                    patterns.push(`^(${value})$`);
                    break;
                case 'starts':
                    patterns.push(`^(?:${value})${b}`);
                    break;
                case 'ends':
                    patterns.push(`${b}(?:${value})$`);
                    break;
                case 'contains':
                    patterns.push(`${b}(${value})${b}`);
                    break;
                case 'excludes':
                    patterns.push(`^((?!${b}${value}${b}).)*$`);
                    break;
                case 'after':
                    patterns.push(`(?:${value}\\s?)([\\w\\-\\s${p}]+)`);
                    break;
                case 'before':
                    patterns.push(`([\\w\\-\\s${p}]+)(?:\\s?${value})`);
                    break;
                case 'range':
                    const rangeExp = to_regex_range_1.default(value.split('-')[0], value.split('-')[1]);
                    patterns.push(`${b}(${rangeExp})${b}`);
                    break;
            }
        }
        for (let i in patterns) {
            const next = parseInt(i, 10) + 1;
            if (!patterns[next])
                break;
            const groups = patterns[i].match(/(\(.+?\))/g);
            if (groups && groups[1] && patterns[next].indexOf(groups[1]) === 0) {
                patterns[i] = patterns[i].replace(groups[1], '');
            }
            const newGroups = patterns[i].match(/(\(.+?\))/g);
            if (newGroups) {
                patterns[i] = newGroups.map((group) => (group.indexOf('(?') !== 0)
                    ? group.replace('(', '(?:')
                    : group).join('');
            }
        }
        if (!patterns.length)
            return new RegExp(/.*/, i);
        const regex = (patterns.length > 1)
            ? new RegExp(`${patterns.join('')}`, i)
            : new RegExp(patterns[0], i);
        return regex;
    }
}
exports.Expression = Expression;
exports.expression = new Expression();
class Conditions {
    constructor(condition, options = {}) {
        this.expressions = {};
        this.matches = {};
        this.captures = {};
        this.config = Object.assign({}, _defaults, options);
        if (!condition)
            return;
        if (typeof condition === 'string' ||
            condition instanceof RegExp ||
            isCondition(condition)) {
            this.add(condition);
        }
        else if (condition instanceof Array) {
            for (let c of condition)
                this.add(c);
        }
        else if (isConditionCollection(condition)) {
            for (let key in condition)
                this.add(condition[key], key);
        }
    }
    add(condition, key) {
        if (!key)
            key = Object.keys(this.expressions).length;
        if (condition instanceof RegExp) {
            this.expressions[key] = condition;
        }
        else if (typeof condition === 'string') {
            this.expressions[key] = exports.expression.fromString(condition);
        }
        else {
            this.expressions[key] = exports.expression.fromCondition(condition, this.config);
        }
        return this;
    }
    exec(str) {
        for (let key in this.expressions) {
            const match = str.match(this.expressions[key]);
            this.matches[key] = match;
            this.captures[key] = (match && typeof match[1] === 'string')
                ? match[1].replace(/(^[\,\-\:\s]*)|([\,\-\:\s]*$)/g, '')
                : undefined;
        }
        return this.matches;
    }
    get success() {
        return (Object.keys(this.matches).every((key) => this.matches[key]));
    }
    get match() {
        let matchKeys = Object.keys(this.matches);
        return (matchKeys.length > 1)
            ? this.success
            : this.matches[matchKeys[0]];
    }
    get matched() {
        let matchKeys = Object.keys(this.matches);
        if (matchKeys.length > 1 ||
            matchKeys.some((key) => isNaN(parseInt(key, 10))))
            return this.matches;
        else if (matchKeys.length === 1)
            return this.matches[matchKeys[0]];
    }
    get captured() {
        let matchKeys = Object.keys(this.matches);
        if (matchKeys.length > 1 ||
            matchKeys.some((key) => isNaN(parseInt(key, 10))))
            return this.captures;
        else if (matchKeys.length === 1)
            return this.captures[matchKeys[0]];
    }
    clear() {
        this.matches = {};
        this.captures = {};
    }
    clearAll() {
        this.clear();
        this.expressions = {};
    }
}
exports.Conditions = Conditions;
